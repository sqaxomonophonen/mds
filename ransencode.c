// cc -Wall ransencode.c -o ransencode

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "rans_byte.h"

struct pair { int start,freq; };

int main(int argc, char** argv)
{
	if (argc != 4) {
		fprintf(stderr, "Usage: %s <scale bits> <input symbol list> <output file>\n\n", argv[0]);
		fprintf(stderr, "Input symbol list must contain \"<start> <freq>\\n\" pairs.\n");
		fprintf(stderr, "These are generated by: text2ransinput.js (+TODOs?)\n");
		fprintf(stderr, "Symbol list must be in *forward* order (it is encoded in reverse\n");
		fprintf(stderr, "order per rANS specs, but that is handled by this program).\n");
		exit(EXIT_FAILURE);
	}
	const int scale_bits = atoi(argv[1]);
	assert(1 <= scale_bits && scale_bits <= 16);
	FILE* in = fopen(argv[2],"r");
	if (in == NULL) {
		fprintf(stderr, "%s: could not open\n", argv[2]);
		exit(EXIT_FAILURE);
	}

	struct pair* pairs = calloc(1<<20, sizeof *pairs);

	int start,freq;
	struct pair* pp = pairs;
	int n_symbols = 0;
	while (fscanf(in, "%d %d\n", &start, &freq) == 2) {
		pp->start = start;
		pp->freq = start;
		pp++;
		n_symbols++;
	}

	const size_t buffer_size = 1<<20;
	uint8_t* buffer = malloc(buffer_size);
	uint8_t* buffer_end = buffer+buffer_size;
	uint8_t* ptr = buffer_end;

	RansState rans;
	RansEncInit(&rans);
	for (int i = 0; i < n_symbols; i++) {
		RansEncSymbol esym = {0};
		RansEncSymbolInit(&esym, pairs[i].start, pairs[i].freq, scale_bits);
		RansEncPutSymbol(&rans, &ptr, &esym);
	}
	RansEncFlush(&rans, &ptr);
	const size_t encsize = buffer_end - ptr;
	printf("%d symbols, %zd bytes\n", n_symbols, encsize);
	fclose(in);

	FILE* out = fopen(argv[3], "wb");
	if (out == NULL) {
		fprintf(stderr, "%s: could not open for writing\n", argv[2]);
		exit(EXIT_FAILURE);
	}
	assert(fwrite(ptr, encsize, 1, out) == 1);
	fclose(out);
	printf("wrote %s\n", argv[3]);

	return EXIT_SUCCESS;
}
